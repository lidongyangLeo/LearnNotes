## My SQL 进阶篇

#### 存储引擎

##### MySQL 体系结构

![mysql体系结构图](../img/mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png)

- 连接层
  - 最上层是一些客户端和链接服务，主要完成一些类似于连接处理，授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。
- 服务层
  - 第二层架构主要完成大多数的核心服务功能，如 SQL 接口，并完成缓存的查询，SQL 的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程，函数等。
- 引擎层
  - 存储引擎真正的负责了 MySQL 中数据的存储和提取，服务器通过 API 和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。
- 存储层
  - 主要是将数据存储在文件系统之上，并完成与存储引擎的交互。

##### 存储引擎简介

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。

- 默认存储引擎： InnoDB

1. 在创建表时，指定存储引擎

   ```sql
   CREATE TABLE 表名（
     字段1 字段1类型 [COMMENT  字段1注释],
     ...
     字段n 字段n类型 [COMMENT  字段n 注释]
   ）ENGINE = INNODB [COMMENT 表注释];
   ```

2. 查看当前数据库支持的存储引擎

   ```sql
   SHOW ENGINES;
   ```

   

##### 存储引擎特点

- InnoDB

  - InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的MySQL存储引擎。
  - 特点：
    - DML操作遵循ACID模型，支持事务。
    - 行级锁，提高并发访问性能；
    - 支持外键`FOREIGN KEY`约束，保证数据的完整性和正确性；
  - 磁盘文件
    - xxx.ibd: xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构(frm, sdi)，数据和索引。
    - 参数： innodb_file_per_table 

- InnoDB 存储引擎特点

  ![逻辑存储结构](/Users/lidongyang/Learn/LearnNotes/Learning/img/InnoDB逻辑存储结构.png)

- MyISAM
  - 介绍
    - MyISAM是MySQL早期的默认存储引擎。
  - 特点：
    - 不支持事务，不支持外键
    - 支持表锁，不支持行锁
    - 访问速度快
  - 磁盘文件
    - xxx.sdi: 存储表结构信息
    - xxx.MYD: 存储数据
    - xxx.MYI: 存储索引
- Memory
  - 介绍
    - Memory 引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。
  - 特点
    - 内存存放
    - hash索引（默认）
  - 文件
    - xxx.sdi: 存储表结构信息

![存储引擎特点](/Users/lidongyang/Learn/LearnNotes/Learning/img/存储引擎特点.png)

##### 存储引擎选择

在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎，对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

- InnoDB:
  - 是MySQL的默认存储引擎，支持事务，外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新，删除操作，那么InnoDB存储引擎是比较合适的选择。 
- MyISAM
  - 如果应用时以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性，并发性要求不是很高，那么选择这个存储引擎是非常合适的。
- Memory:
  - 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory的缺陷就是对表的大小有限制，太大的表五福缓存在内存中，而且不误保障数据的安全性。 

#### 索引

- 索引概述

  - 索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。
  - 无索引（全表扫描）
  - 有索引  

  - 优缺点：
    - 优点：
      - 提高数据检索的效率，降低数据库的IO成本
      - 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗
    - 劣势:
      - 索引列也是要占用空间的。
      - 索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT,UPDATE,DELETE时，效率降低。

- 索引结构

  - MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下集中：

  ![索引结构](/Users/lidongyang/Learn/LearnNotes/Learning/img/索引结构.png)

​		![索引结构支持情况](/Users/lidongyang/Learn/LearnNotes/Learning/img/索引结构支持情况.png)

我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。



##### 二叉树



![二叉树](/Users/lidongyang/Learn/LearnNotes/Learning/img/二叉树.png)



二叉树缺点： 顺序插入时，会形成一个链表，查询性能大大降低，大数据量情况下，层级较深，检索速度慢。

红黑树： 大数据量情况下，层级较深，检索速度慢。



##### B-Tree(多路平衡查找树)

以一颗最大度数（max-degree）为5（5阶）的b-tree为例（每个节点最多存储4个key，5个指针）

     1. 树的度数指的是一个节点的子节点个数。

![B-Tree](/Users/lidongyang/Learn/LearnNotes/Learning/img/B-Tree.png)

##### B+Tree

相对于B-Tree区别：

	1. 所有的数据都会出现在叶子节点
	1. 叶子节点形成一个单向链表

MySQL索引数据结构对经典的B+Tree进行了优化，在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序执行的B+Tree,提高区间访问的性能。



##### Hash 

哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。

如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞）,可以通过链表来解决。

​	Hash索引特点

		1. Hash索引只能用于对等比较（=， in）, 不支持范围查询 （between, >, < , ....）
		1. 无法利用索引完成排序操作
		1. 查询效率高，通常只需要一次检索就可以了，效率通常要高于B+Tree索引。



   存储引擎支持

​	在MySQL中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。



为什么InnoDB存储引擎选择使用B+Tree索引结构？

	   1. 相对于二叉树，层级更少，搜索效率高；
	   1. 对于B-Tree,无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低。
	   1. 相对于Hash索引，B+Tree支持范围匹配及排序操作；

 

- 索引分类

  ![索引分类](/Users/lidongyang/Learn/LearnNotes/Learning/img/索引分类.png)

  - 在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：

    ![InnoDB索引分类](/Users/lidongyang/Learn/LearnNotes/Learning/img/InnoDB索引分类.png)

     - 聚集索引选取规则
       - 如果存在主键，主键索引就是聚集索引。
       - 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
       - 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个`rowid`作为隐藏的聚集索引。

- 索引语法

- SQL性能分析

- 索引使用

- 索引设计原则

#### SQL 优化

#### 视图/存储过程/触发器

#### 锁

#### InnoDB 引擎

#### MySQL 管理
